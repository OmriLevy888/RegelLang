If a function is declared within another function, is cannot access variables
in the containing function as that would create weird lifetime situations.

Visitor classes for definitions.

TODO:
  - Definition order
  - Globals
  - Variables from outer functions not available in inner functions

Important change:
-----------------
A function declaration may only have a name if it is the only expression in the
current ExpressionStatement, therefore, these are the only functions that can be
referenced even if they are declared after the place of reference.

================================================================================
Type symbols
Function overload
Bin ops
Unary ops
Invoke with params
Conditionals
While
For
Modules/Imports
Globals (initialization and destruction)
Classes

Type representation:
- Parser:
  Only needs to make sure it is a valid type syntactically
- Codegen:
  Need to store members, methods, constructors...
  struct typeDescriptor {
    TypeDescriptorFlags m_flags; // things such as whether the type is
                                 // trivally copiable
    std::vector<FunctionSymbolPtr> m_ctors;
    FunctionSymbolPtr m_dtor;
    SymbolMapPtr m_members; // all fields and methods
  };



class TypeSymbolBase {
protected:
  TypeTraits m_traits;
};
using TypeSymbolPtr = std::shared_ptr<TypeSymbolBase>;

class BasicTypeSymbol : public TypeSymbolBase {
private:
  std::vector<FunctionSymbolPtr> m_ctors;
  FunctionSymbolPtr m_dtor;
  SymbolMapPtr m_members;
};

class FunctionTypeSymbol : public TypeSymbolBase {
private:
  TypeSymbolPtr m_retType;
  std::vector<TypeSymbolPtr> m_params;
};

class ArrayTypeSymbol : public TypeSymbolBase {
private:
  TypeSymbolPtr m_containedType;
};

class ModifiedTypeSymbol : public TypeSymbolBase {
private:
  TypeModifiers m_modifiers;
  TypeSymbolPtr m_contained;
}

================================================================================
Parser types:
- TypeBase -> contains type m_modifiers
- BasicType -> TypeBase with an identifier
- FunctionType -> TypeBase with representation of function type
- No need for type map, just have static instances for builtin types
  (singeltons) for performance when writing tests
- Equasion done using basic type string representation comparison

merge basic identifier and compound identifier





llvm::FunctionType::get(retType, paramTypes, isVarArg);




- Fix all symbols to use TypeSymbolPtr and fix all include problems and make
  sure the parser uses the new Identifier type and so do all ASTNode sub-classes
    
- VariableSymbol::make
- FunctionSymbol::make

TODO:
implement BasicTypeSymbol::make and FunctionTypeSymbol::make from
`const TypeNodePtr &` as argument and implement getType() and getFunctionType()
methods of `SymbolMap` type. Lastly, fix compilation setup so that tests work
again and fix them to use the new classes.
